#!/usr/bin/env fennel

(local http-request (require :http.request))
(local cjson (require :cjson))
(local view (require :fennel.view))

(fn basename [path]
  (string.gsub path "(.*/)(.*)" "%2"))

(fn slurp [path]
  (with-open [buf (io.open path)]
    (buf:read :*all)))


(local nix {})

(fn nix.license-from-github-license-key [key]
  (let [map {:agpl-3.0 "agpl3Only"
             :apache-2.0 "asl20"
             :bsd-2-clause "bsd2"
             :bsd-3-clause "bsd3"
             :bsl-1.0 "boost"
             :cc0-1.0 "cc0"
             :epl-2.0 "epl20"
             :gpl-2.0 "gpl2Only"
             :gpl-3.0 "gpl3Only"
             :lgpl-2.1 "lgpl21Only"
             :mit "mit"
             :mpl-2.0 "mpl20"
             :unlicense "unlicense"}]
    (. map key)))

(fn nix.prefetch-url [url]
  (let [pipe (io.popen (string.format "nix-prefetch-url --type sha256 %s 2>/dev/null" url))
        sha256 (string.gsub (pipe:read :*all) "\n$" "")]
    (pipe:close)
    sha256))


(local http {})

(fn http.get [uri headers]
  (let [request (http-request.new_from_uri uri)]
    (each [key val (pairs (or headers {}))]
      (request.headers:append key val))
    (let [(headers stream) (assert (: request :go))
          body (assert (stream:get_body_as_string))]
     (if (= (headers:get ":status") :200)
         (values body
                 headers)
         (error (view {: body
                       : headers})))))) 


(local github {})

(fn github.get [query token]
  (let [token (or token (os.getenv "GITHUB_TOKEN"))]
    (if (not token)
        (error "Please set GITHUB_TOKEN for your github access authentication")
        (let [(body headers) (http.get (string.format "https://api.github.com/%s" query)
                                       {:authorization (string.format "token %s" token)
                                        :content-type "application/json"})]
          (values (cjson.decode body)
                  headers)))))


(set github.repo {:type "github"})

(set github.repo.__index github.repo)

(fn github.repo.new [full-name-or-owner name]
  (let [info (let [full-name (if (not name)
                                 full-name-or-owner
                                 (string.format "%s/%s" full-name-or-owner name))]
               (github.get (string.format "repos/%s" full-name)))
        obj {:full-name info.full_name
             :owner (if (not name)
                        (pick-values 1 (string.match info.full_name "^([^/]+)/([^/]+)$"))
                        full-name-or-owner)
             :name info.name
             :default-branch info.default_branch
             :description info.description
             :fork? info.fork
             :homepage (if (or (= info.homepage "")
                               (type info.homepage :userdata)) ; #<userdata NULL>
                           (string.format "https://github.com/%s" info.full_name)
                           info.homepage)
             :license (if (and info.license
                               (not= (type info.license) :userdata)) ; #<userdata NULL>
                          {:key info.license.key
                           :name info.license.name}
                          nil)}]
    (setmetatable obj github.repo)))

(fn github.repo.get-recent-commit [self branch]
  (let [branch (or branch self.default-branch)
        body (github.get (string.format "repos/%s/commits/%s" self.full-name branch))]
    {: branch
     :date body.commit.committer.date
     :sha body.sha}))


(local gitlab {})

(fn gitlab.get [query]
  (let [(body headers) (http.get (string.format "https://gitlab.com/api/v4/%s" query)
                                 {:content-type "application/json"})]
    (values (cjson.decode body)
            headers)))

(set gitlab.project {:type "gitlab"})

(set gitlab.project.__index gitlab.project)

(fn gitlab.project.new [path-with-namespace-or-namespace path]
  (let [info (let [path-with-namespace
                    (if (not path)
                        path-with-namespace-or-namespace
                        (string.format "%s/%s" path-with-namespace-or-namespace path))
                   escaped-path-with-namespace (string.gsub path-with-namespace "/" "%%2F")]
               (gitlab.get (string.format "projects/%s" escaped-path-with-namespace)))
        obj {:full-name info.path_with_namespace
             :owner info.namespace.path
             :name info.path
             :default-branch info.default_branch
             :description info.description
             :fork? nil
             :homepage info.web_url
             :license nil}]
    (setmetatable obj gitlab.project)))

(fn gitlab.project.get-recent-commit [self branch]
  (let [branch (or branch self.default-branch)
        body (gitlab.get (string.format "projects/%s%%2F%s/repository/branches/%s"
                                        self.owner
                                        self.name
                                        branch))]
    {: branch
     :date body.commit.committed_date
     :sha body.commit.id}))


(local plugin {})

(set plugin.__index plugin)

(fn plugin.new [spec]
  (match (type spec)
    :string (let [repo (match (string.match spec "^([^:]+):([^:]+)$")
                         ("gitlab" path-with-namespace) (gitlab.project.new path-with-namespace)
                         ("github" full-name) (github.repo.new full-name)
                         _ (github.repo.new spec))
                  recent-commit (repo:get-recent-commit)
                  attr-name (string.gsub repo.name "%." "-")
                  obj {: attr-name 
                       :pname attr-name
                       :version (string.match recent-commit.date "^%d%d%d%d%-%d%d%-%d%d")
                       :full-name repo.full-name
                       :repo-type repo.type
                       :owner repo.owner
                       :name repo.name
                       :branch recent-commit.branch
                       :rev recent-commit.sha
                       :url (match repo.type
                              :github (string.format "https://github.com/%s/archive/%s.tar.gz"
                                                     repo.full-name
                                                     recent-commit.sha)
                              :gitlab (string.format "https://gitlab.com/api/v4/projects/%s%%2F%s/repository/archive.tar.gz?sha=%s"
                                                     repo.owner
                                                     repo.name
                                                     recent-commit.sha)
                              _ (error "undefined repo type"))
                       :description repo.description
                       :homepage repo.homepage
                       :license repo.license}]
               (set obj.sha256 (nix.prefetch-url obj.url))
               (setmetatable obj plugin))
    _ (error "plugin spec undefined")))

(fn plugin.to-nixexpr [self]
  (string.format
    "  %s = buildVimPlugin {
    pname = \"%s\";
    version = \"%s\";
    src = fetchurl {
      url = \"%s\";
      sha256 = \"%s\";
    };
    meta = with lib; {
      description = \"%s\";
      homepage = \"%s\";%s
    };
  };
"
    self.attr-name
    self.pname
    self.version
    self.url
    self.sha256
    self.description
    self.homepage
    (let [license (and self.license
                       (nix.license-from-github-license-key self.license.key))]
      (if license
          (string.format "\n      license = with licenses; [ %s ];" license)
          ""))))

(fn plugin.to-markdown-bullet [self]
  (string.format
    "- [%s](%s) (branch: %s, recent commit: %s, package name: `%s`)\n"
    (match self.repo-type
      :github self.full-name
      :gitlab (string.format "gitlab:%s" self.full-name)
      _ (error "undefined plugin repo type"))
    self.homepage
    self.branch
    self.version
    self.attr-name))

(fn plugin.to-markdown-table-row [self]
  (string.format
    "| [%s](%s) | %s | %s | `%s` |\n"
    (match self.repo-type
      :github self.full-name
      :gitlab (string.format "gitlab:%s" self.full-name)
      _ (error "undefined plugin repo type"))
    self.homepage
    self.branch
    self.version
    self.attr-name))


(local specs (cjson.decode (slurp "manifest.json")))


(fn main []
  (local program-name (basename (. arg 0)))
  (with-open [nix (io.open "pkgs/vim-plugins.nix" :w)
              readme (io.open "README.md" :w)]
    (nix:write "{ lib, buildVimPlugin, fetchurl }:\n\n{\n")
    (readme:write (slurp "assets/README_header.md"))
    (each [_ spec (ipairs specs)]
      (io.stderr:write (string.format "%s: update %s..." program-name spec))
      (let [pkg (plugin.new spec)]
        (nix:write (pkg:to-nixexpr))
        (readme:write (pkg:to-markdown-table-row)))
      (io.stderr:write "done\n"))
    (nix:write "}\n")
    (readme:write (slurp "assets/README_footer.md"))))

(main)
